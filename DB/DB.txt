################################################################################
データベースシステム Ver1.70			Copyright (C)2025 nabe@abk
################################################################################
[TAB=8]

################################################################################
■プラグイン仕様
################################################################################

・「テーブル名」「カラム名」は小文字のみ。

・どのような（汚染された）データや引数を渡されても、
　SQLインジェクション等の問題は起こらない（SQLを直接指定する引数を除く）。

・空文字は、すべてのDB上でNULLとして扱われ、NULLと空文字を区別することできない。
　xxx_match() における空文字とのマッチングは、IS NULLとして扱われる。

################################################################################
■TextDB（Text DataBase）の仕様
################################################################################

　特別な外部ライブラリや外部データベースを使わずに、擬似的なデータベースシステ
ムを提供します。ただし、信頼性・機能面では RDBMS に劣ります。
（大規模データ以外では、テキストDBが速度面で優ることがあります。）

●仕様
・カラム名の「大文字、小文字」を区別します。必ず「小文字」を使用してください。

・NULLカラムは内部的に空文字として扱われます。

・テーブル作成時、参照制約は記録されますが、制約自体は無視されます。

・index に TAB と 改行(\n) および "\0"（ヌル文字）を記録できません。
　よって、index化されたカラムを検索時、これらはスペース1個として扱われます。

・LEFT JOINを実行する際、右テーブルの参照カラムが UNIQUE でなければいけません。
　UNIQUEでないカラムを指定しても、左テーブルは複製されません。

・insert/update/create_table のSQLデフォルト値は、以下のみ対応しています。
	CURRENT_TIMESTAMP

################################################################################
■メンバ変数
################################################################################
DB.ID		接続先データベースを一意識別するID
DB.ignore_error	エラー無視（warning()となる）。

●TextDB
DB.dir		データベース保持用ディレクトリ ("db/")。"/" で終わること。
DB.file_ex	個別データファイルの拡張子 (".dat")
DB.index_file	インデックスファイル名標準 ("#index.dat")
		拡張子以外の部分が数字のみのファイル名は不可

################################################################################
■カラムの型
################################################################################
int		整数（32bit）
bigint		整数（64bit）
float		小数
flag		フラグ(0 or 1)
boolean		フラグの別名
date		日付型。'YYYY-MM-DD'
timestamp	タイムスタンプ型。'YYYY-MM-DD hh:mm:ss'（精度「秒」）
text		テキスト
ltext		大きいテキスト(64KB超え)

################################################################################
■関数マニュアル（SELECT系）
################################################################################
================================================================================
●データの検索
================================================================================
 $rah         = $DB->select($table, \%h);
($rah, $hits) = $DB->select($table, \%h);

	$table			テーブル名。テーブル名に名前をつけることもできる。
				（例）"usr u" -> "select * from usr as u"

	$h{match}->{<col>}	一致検索。col とその値。
				値が配列リファレンスのとき、いずれかの値との一致検索
	$h{not_match}->{<col>}	不一致検索。配列指定可能。

	$h{max}->{<col>}	値比較（以下）
	$h{min}->{<col>}	値比較（以上）
	$h{lt}->{<col>}		値比較（指定した値より小さい）
	$h{gt}->{<col>}		値比較（指定した値より大きい）
	$h{flag}->{<col>}	フラグ検索 col と論理（1 / 0）
	$h{boolean}->{<col>}	flag の別名。両方指定した場合 $h{flag} が優先される。

	$h{is_null}		IS NULL検索をするカラム（配列リファレンス）
	$h{not_null}		IS NOT NULL検索をするカラム（配列リファレンス）
				※DBにおいて "" は常に NULL として扱われる

	$h{search_words}	検索文字列（配列リファレンス）
	$h{search_not}		含まない検索をする文字列（配列リファレンス）
	$h{search_cols}		部分検索カラム（配列リファレンス） / case insensitive
	$h{search_match}	一致検索カラム（配列リファレンス） / case insensitive
	$h{search_equal}	一致検索カラム（配列リファレンス） / case sensitive

	$h{offset}		取得開始するオフセット
	$h{limit}		取得最大行数

	$h{sort}		ソートするカラム。複数指定が配列refで。
				"-col" と指定すると、降順になる。

	$h{cols}->[]		必要なカラムを指定（配列リファレンスかスカラ）
				cols が未定義時はすべて

	$h{want_sth}		(RDBMSのみ) 取得結果ではなく $sth を返す。

　複数検索条件の場合 and として扱われる。

　特殊な引数
	$h{RDB_where}		(RDBMSのみ) where条件を直接「追加(and)」指定する。
				危険であるので変数埋め込みは絶対しないこと。
				「' ; \」および「\x80-\xff」以降は除去される。
	$h{RDB_values}		(RDBMSのみ) RDB_whereの「?」に与える値
	$h{RDB_order}		(RDBMSのみ) ORDER条件を直接指定する。
				sort条件と並列指定した場合は、
				RDB_order の後にsort条件が評価される。

　LEFT JOIN: $h{ljoin} = $lj	ハッシュまたはハッシュの配列として指定する。
	$lj->{table}		LEFT JOIN するテーブル
	$lj->{left}		JOIN条件の左側。"name.col" 形式。
	$lj->{right}		JOIN条件の右側。"name.col" 形式。
	$lj->{cols}->[]		最終結果に追加で返す $lj->{table} のカラム。
				"col name"と書くと、colカラムをnameとして取り出します。
				※メインの $h{cols} では名付けはできません。

  （例）$h->{ljoin} = {
		table	=> 'usr u',
		left	=> 'l.u_pkey',
		right	=> 'u.pkey',
		cols	=> ['name usr_name']
	}
	$DB->select('log l', $h);
	--> SELECT l.*, u.name as usr_name FROM log l LEFT JOIN usr u ON l.u_pkey=u.pkey

Ret:
	$rah			（検索結果の）ハッシュリファレンスの配列
	$hits			該当件数

================================================================================
●データの簡易検索
================================================================================
$rah = $DB->select_match($table, $col, $val);
$rah = $DB->select_match($table, $col, $val, $col2, $val2, ...);

	$table		テーブル名

	$col		検索カラム名
	$val		一致検索する値。複数値の場合は配列refを与える

　条件は「カラム名と値」の組ごとに追加してください。

　$match の特殊指定。詳細は select を参照
	*limit			limitを指定
	*sort			sortを指定。カラム名に'-'を付けると降順
	*cols			取得するカラムを指定
	-(col)			マッチしない指定

（例）sort複数指定
	select_match('table', '*sort', ['col1', 'col2']);

Ret:
	$rah			（検索結果の）ハッシュリファレンスの配列


================================================================================
●データの簡易検索（１つ抽出）
================================================================================
$h = $DB->select_match_limit1($table, $col, $val);
$h = $DB->select_match_limit1($table, $col, $val, $col2, $val2, ...);

	$table		テーブル名

　マッチング引数は select_match を参照。
　内部的に select_match() を呼び出しています。

Ret:
	$h		（成功時）ハッシュリファレンス
	$h=undef	（失敗時）

================================================================================
●データの簡易検索（存在確認）
================================================================================
$pkey = $DB->select_match_pkey1($table, $col, $val);
$pkey = $DB->select_match_pkey1($table, $col, $val, $col2, $val2, ...);

	$table		テーブル名

　指定した条件に合う行の、「pkey」を1つだけ取り出します。
　内部的に select_match() を呼び出しています。

Ret:
	0 以外		（成功時）
	0		（失敗時）

================================================================================
●データの集計
================================================================================
$rah = $DB->select_by_group($table, \%h);

	$table			テーブル名
	$h{group_by}		GROUP BY をするカラム（1つのみ。省略可）
	$h{min_cols}		最小値をとるカラム（配列可/省略可）
	$h{max_cols}		最大値をとるカラム（配列可/省略可）
	$h{sum_cols}		総和をとるカラム　（配列可/省略可）

	$h{xxx}			ソート条件/検索条件/LEFT JOIN。
				select と同一のものが使用できる。

Ret:
	$rah			（検索結果の）ハッシュリファレンスの配列
				_count  : count(pkey)
				xxx_sum : sum('xxx')

	SQL で書けば次のようになる。

SELECT	$group_col,
	count(pkey) as _count,
	max($max_col) as "${max_col}_max",
	sum($sum_col) as "${sum_col}_sum",
	FROM $table GROUP BY $group_col

	カラム名にテーブル名が含まれる場合、テーブル名は無視されます。

	$DB->select_by_group('score s', { group_by => 'u_pkey', max_cols => 's.point' });
	SELECT count(pkey) as _count, max(s.point) as point_max FROM score s GROUP BY u_pkey

################################################################################
■関数マニュアル（SELECT以外）
################################################################################
================================================================================
●テーブルの確認
================================================================================
$r = $DB->find_table( $table );

	$table		テーブル名

Ret:
	$r  = 0		見つからない（存在しない）
	$r  = 1		見つかった（存在する）

================================================================================
●データの挿入
================================================================================
$r = $DB->insert($table, \%h);

	$table		テーブル名
	$h{<col>}	カラム col のデータ
	$h{*<col>}	カラムデータを直接指定（例）$h{'*x'}=CURRENT_TIMESTAMP

　既に同じpkeyが存在した場合、挿入自体が失敗する。
　pkeyを省略した場合、自動で番号が振られる。

（TextDBの制約）$h{*<col>} は使用できません。

Ret:
	$r = 0		失敗
	$r		成功：挿入したデータの pkey

================================================================================
●pkeyの生成
================================================================================
$r = $DB->generate_pkey($table);

	$table		テーブル名

Ret:
	$r = 0		失敗
	$r>0		一意性が保証された pkey

================================================================================
●データの更新
================================================================================
$r = $DB->update_match($table, \%h, $col, $val);
$r = $DB->update_match($table, \%h, $col, $val, $col2, $val2, ...);

	$table		テーブル名

	$h{<col>}	カラム col のデータ
	$h{*<col>}	カラムデータをSQLで指定（例）$h{'*x'}=x+1, $h{'*x'}=CURRENT_TIMESTAMP

	$col		検索カラム名
	$val		一致検索する値。複数値の場合は配列refを与える

　条件をすべて省略すると、すべての行を更新します。
　条件は「カラム名と値」の組ごとに追加してください。
  カラム名の手前に'-'をつけると一致しない値を検索します。

※TextDBの制約

　$h{*<col>} で使用できるのは () と単純な加減乗除のみです。関数は呼び出せません。
　参照するカラムに NULL が含まれる場合、式の内容に関わらず結果は NULL になります。
　文字列操作は想定していません。正常に動作する式のみ動作します。
	（許可演算子）+ - * / % | & < >

　また $h{<col>} と $h{*<col>}の重複は禁止です。重複時合の動作は不定です。

Ret:
	$r  = 0		失敗
	$r != 0		成功（更新した行数）

================================================================================
●データの削除
================================================================================
$r = $DB->delete_match($table, $col, $val);
$r = $DB->delete_match($table, $col, $val, $col2, $val2, ...);

	$table		テーブル名

	$col		検索カラム名
	$val		一致検索する値。複数値の場合は配列refを与える

　条件をすべて省略すると、すべての行を削除します
　条件は「カラム名と値」の組ごとに追加してください。
  カラム名の手前に'-'をつけると一致しない値を検索します。

Ret:
	$r = 0		失敗
	$r		成功（削除した行数）

================================================================================
●テーブルの作成
================================================================================
$r = $DB->create_table($table, \@colums);

	$table			テーブル名
	@colums			ハッシュリファレンス配列
	$colums->[$i]		$i 個目のカラムのハッシュ
	  $h->{name}		カラム名
	  $h->{type}		カラム型
	  $h->{unique}		そのカラムにユニーク制約を付けるか
	  $h->{not_null}	NOT NULL制約を付けるか
	  $h->{default}		デフォルト値
	  $h->{default_sql}	デフォルト値（SQL）。{default}より優先される。
	  $h->{ref}		外部キー制約（ table_name.col_name 形式の文字列 ）

	  $h->{index}		INDEX化する。uniqueなら必ずindex化される。
	  $h->{index_tdb}	TextDBの時にはINDEX化する。(※)

・テーブル名、カラム名に使用出来るのは英小文字と "_" のみです。
・外部キー制約は、DB側の実装によって無効な場合があります。
・カラムpkeyについて
	・pkey は主キー（SERIAL/int）として自動作成されます。
	・name=pkey, type=bigserial を指定すると、pkeyをbigint型にできます。
	・この際、type以外のオプションはすべて無視されます。

Ret:
	$r  = 0			成功
	$r != 0			失敗

※TextDBでは、$_->{index} または $_->{index_tdb} が指定された要素がindexになります。
　テキストDBは検索対象となる要素は、index化しないとパフォーマンスが悪化します。
（全文検索の対象などの大きいデータは除く。
　index化するデータ量が極端に増えると逆にパスォーマンスが低下します。）

================================================================================
●テーブルの作成
================================================================================
$r = $DB->create_table_wrapper($table, $info);
$r = $DB->create_table_wrapper($table, $info, \@columns);

　簡易なインターフェイスでテーブルを作成する wrapper。

	$info		テキストまたはテキストを行分割した配列ハッシュ。
	@colums		create_tableと同一。$infoに追加で設定。

Ret:
	$r  = 0			成功
	$r != 0			失敗

（例）
	$DB->create_table_wrapper('usr', <<INFO);
		pkey		serial PRIMARY KEY		# not change

		id		text NOT NULL UNIQUE
		name		text NOT NULL			# display name
		pass		text NOT NULL			# crypted
		email		text UNIQUE

		login_c		int NOT NULL DEFAULT 0		# login count
		login_tm	bigint				# last login time (UTC)
		fail_c		int NOT NULL DEFAULT 0		# login fail count (clear on success)
		fail_tm		bigint				# last failed time (UTC)
		disable		flag NOT NULL 			# account is disabled
		isadmin		flag NOT NULL			# account is admin

		INDEX		id
		INDEX		email
		INDEX		isadmin
INFO
	$DB->create_table_wrapper("usr_sid", <<INFO);
		pkey		serial PRIMARY KEY		# not change

		id		text NOT NULL ref(usr.id)
		sid		text NOT NULL
		login_tm	timestamp NOT NULL
		msg		text

		INDEX		id
		INDEX		sid
		INDEX_TDB	login_tm, text			# index on TextDB
INFO

	pkeyカラムは省略しても問題ありません。
	ソース中のテーブル定義を分かりやすくする理由以外で書く必要もありません。
	"INDEX" は必ず大文字で書く必要があります。
		複数列挙（マルチカラムindex）は指定できません。
	"INDEX_TDB" は複数列挙可能です（それぞれ単独のINDEX_TDB指定とみなされます）。

================================================================================
●テーブルの作成
================================================================================
$r = $DB->drop_table($table);

	$table		テーブル名

Ret:
	$r  = 0		成功
	$r != 0		失敗（1=テーブルが見つからない，2以上=それ以外）

　この関数はむやみに使用するべきではない。

################################################################################
■関数マニュアル（その他）
################################################################################
================================================================================
●トランザクション
================================================================================
$DB->begin();
$DB->commit();
$DB->rollback();

　トランザクションを操作しますが、DBライブラリによっては実装されてないかも
しれません。この関数はもっぱら大量の更新処理を高速に処理するため（中間の書
き戻しを省略するため）に使用されます。

　コミット失敗時は自動的にrollbackされます。rollbackの呼び出しは不要です。

・TextDB
select/insert/update/delete のみ対応。
同じテーブルに対し同時に１つしかトランザクションは走らない。

・MariaDB/MySQL
テーブルの作成・削除・変更はトランザクションの対象外です。
MyISAMではほぼすべてのトランザクションは無視されます。

Ret:
	$r = $DB->commit(); 
		 0	成功
		-1	ロールバック（途中でエラーがあった）

################################################################################
■補助関数
################################################################################
================================================================================
●カラム追加
================================================================================
$r = $DB->add_column($table, \%h);

	%h		追加するカラム情報（create_table参照）

Ret:
	$r  = 0		成功
	$r != 0		失敗

================================================================================
●カラム削除
================================================================================
$r = $DB->drop_column($table, $col);

	$col		削除するカラム名

　削除したカラムのデータが、select したときに返ることもある。
（そういう実装も許される）

Ret:
	$r  = 0		成功
	$r != 0		失敗

================================================================================
●INDEXの作成
================================================================================
$r = $DB->create_index($table, $col);

	$col		INDEXを作成するカラム名。
			RDBMSの場合のINDEX名: "${table}_${col}_idx"

Ret:
	$r  = 0		成功
	$r != 0		失敗

================================================================================
●INDEXの削除
================================================================================
$r = $DB->drop_index($table, $col);

	$col		INDEXを削除するカラム名
			RDBMSの場合のINDEX名: "${table}_${col}_idx"

Ret:
	$r  = 0		成功
	$r != 0		失敗

================================================================================
●NOT NULL制約の設定
================================================================================
$r = $DB->set_not_null($table, $col);

	$col		NOT NULL制約を設定するカラム名。

Ret:
	$r  = 0		成功
	$r != 0		失敗

================================================================================
●NOT NULL制約の削除
================================================================================
$r = $DB->drop_default($table, $col);

	$col		NOT NULL制約を削除するカラム名。

Ret:
	$r  = 0		成功
	$r != 0		失敗

================================================================================
●DEFAULT値の設定
================================================================================
$r = $DB->set_default($table, $col, $val, $sql_val);

	$col		DEFAULT値を設定するカラム名。
	$val		値。
	$sql_val	SQLとして解釈される値。上とどちらかのみ指定する。

（例）
	$DB->set_default('tbl', 'col', 123);
	$DB->set_default('tbl', 'col', undef, 'CURRENT_TIMESTAMP');
	$DB->set_default('tbl', 'col', undef, 'NULL');

Ret:
	$r  = 0		成功
	$r != 0		失敗

================================================================================
●DEFAULT値の削除
================================================================================
$r = $DB->drop_default($table, $col);

	$col		DEFAULT値を削除するカラム名。

Ret:
	$r  = 0		成功
	$r != 0		失敗

################################################################################
■管理関数
################################################################################
================================================================================
●DBのバージョン取得
================================================================================
$ver = $DB->db_version();

Ret:	$ver		データベースのVersion文字列

================================================================================
●テーブル一覧の取得
================================================================================
$ary = $DB->get_tables();

Ret:	$ary		テーブルのリスト（配列リファレンス）

================================================================================
●テーブルのカラム一覧
================================================================================
$ary = $DB->get_colmuns_info($table);

	$table		テーブル名

Ret:	$ary		テーブルのリスト（ハッシュリファレンスの配列）
			情報の形式は DB モジュールによります。

================================================================================
●SQLの実行
================================================================================
($result, $log_ary) = $DB->sql_console($sql);

　実行前に $self->{admin}=1 を設定しておく。

Ret:	$result		戻り値（ハッシュリファレンスの配列）
	$log_ary	実行時のログ情報。エラー情報など。

　SQLを実行し結果を返します。TextDBでは、sql_emulator() が実行されます。

================================================================================
●SQLのエミュレーターの実行
================================================================================
($result, $log_ary) = $DB->sql_emulator($sql);

　実行前に $self->{admin}=1 を設定しておく。

Ret:	$result		戻り値（ハッシュリファレンスの配列）
	$log_ary	実行時のログ情報。エラー情報など。

　SQLをエミュレーションし実行します。
　自前のパーサにより分解されたSQLは、DBモジュール共通ファンクションを介して
実行されます。
　あくまでAPIテスト用であり、限定的なSQLが動作します。

################################################################################
■RDB関数
################################################################################

　RDBMSでのみ実装されている関数群。
　DBに依存する実装以外では使用しないでください。

================================================================================
●[share] where句を指定して簡易select
================================================================================
$ary  = $DB->select_where($table, $where);
$ary  = $DB->select_where($table, $where, @ary);
$h    = $DB->select_where_limit1($table, $where);
$h    = $DB->select_where_limit1($table, $where, @ary);
$pkey = $DB->select_where_pkey1 ($table, $where);
$pkey = $DB->select_where_pkey1 ($table, $where, @ary);

	where句を指定して、簡易検索を実行します。
	内部的には、RDB_whereを指定し select() を呼び出しています。

（例）
	$DB->select_where($table, 'x is null');
	$DB->select_where_limit1($table, 'x=3 OR y!=4');
	$DB->select_where_pkey1 ($table, 'x_pkey=? OR y_pkey=?', 3, 4);

================================================================================
●do_sql
================================================================================
$sth = $DB->do_sql("SQL")
$sth = $DB->do_sql("SELECT * FROM table WHERE pkey=? AND x=? OR y=?", @ary)

Ret:
	$sth	execute済の DBI $sth が返されます。
		失敗時は undef が返ります。

================================================================================
●do_sql_rows
================================================================================
$rows = $DB->do_sql_rows("SQL")

Ret:
	$rows	DBI の $sth->rows が返されます。
		失敗した場合は undef が返されます。

================================================================================
●select_sql
================================================================================
$hary = $DB->select_sql("SELECT * FROM table WHERE pkey=? AND x=? OR y=?", @ary)

Ret:
	$hary	結果のハッシュ配列が返されます。
		該当がない場合やエラー時は空配列が返ります。

================================================================================
●dbhのロード
================================================================================
$dbh = $DB->load_dbh();

	DBIのコネクションハンドル $dbh をロードします。

================================================================================
●prepare
================================================================================
$sth = $DB->prepare();

	DBIに対し prepare を発行し戻り値を得ます。

================================================================================
●where句のみの生成
================================================================================
($where_sql, $values_ary) = $DB->generate_select_where($h)

	$h	select()の引数と同一。

	DBの仕様に沿った「where句」を生成します。

Ret:
	$where_sql	空文字 または ' WHERE pkey is null' 等の文字列
	$values_ary	WHEREのフレーズホルダー用の配列リファレンス

================================================================================
●切断/再接続
================================================================================
$DB->disconnect();
$DB->reconnect( $flag );

	$flag …… 1 の場合、強制再接続します。

	DB と接続が切れている場合、再接続します。
	接続が切れていなければ何もしません。
	DBI環境以外でも実装されますが、何も処理しません。

################################################################################
■エラー関連
################################################################################
================================================================================
●set_trace
================================================================================
my $r = $DB->set_trace( $flag );
	$flag = 0	trace off（ディフォルト）
	$flag = 1	trace on （SQLをdebug出力。TextDBではeval等を出力）

Ret:
	$r		設定前のモード

================================================================================
●エラー無視
================================================================================
$DB->{ignore_error} に値を設定。

	$flag = 0	$ROBJ->error()   に出力
	$flag = 1	$ROBJ->warning() に出力

