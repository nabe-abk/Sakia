################################################################################
データベースシステム Ver1.33			Copyright (C)2022 nabe@abk
################################################################################
[TAB=8]

################################################################################
■プラグイン仕様
################################################################################

・「テーブル名」「カラム名」は小文字以外使用しないこと。

・どのような（汚染された）データや引数を渡されても、SQLインジェクション等の
　セキュリティーホールが起こってはならない。

・空文字はDB上では NULL として扱われ、NULLと空文字を区別することはできません。
　（取扱い上も区別しないでください）
　空文字とのマッチング条件は、IS NULLとして実行されます。

################################################################################
■DB_text（テキストデータベース）解説
################################################################################

　特別な外部ライブラリや外部データベースを使わずに、擬似的なデータベースシステ
ムを提供します。ただし、信頼性・機能面では RDBMS に劣ります。
（大規模データ以外では、速度面ではテキストのほうが速いことが多々あります）

●仕様
・index に TAB と 改行(\n) を記録できません。
　よって、文字列検索やユニーク制約時にTAB/\nはspace1個として扱われます。

・UNIQUE制約カラムは、自動的にindexになります。

・NULLカラムは内部的に空文字として扱われます。

################################################################################
■メンバ変数
################################################################################
DB.db_id			接続先データベースを一意識別するID

●各DBシステムの動作設定　※（　）内はデフォルト
DB_text.dir			データベース保持用ディレクトリ ("db/")
				"/" で終わること。
DB_text.file_ex			個別データファイルの拡張子 (".dat")
DB_text.index_file		インデックスファイル名標準 ("#index.dat")
				拡張子以外の部分が数字のみのファイル名は不可

################################################################################
■カラムの型
################################################################################
int	整数
float	小数
flag	フラグ(0 or 1)
text	テキスト
ltext	大きいテキスト(64KB超え)

################################################################################
■関数マニュアル（必須）
################################################################################
================================================================================
●テーブルの作成
================================================================================
$r = $self->create_table($table, \@colums);

	$table			テーブル名
	@colums			ハッシュリファレンス配列
	$colums->[$i]		$i 個目のカラムのハッシュ
	  $h->{name}		カラム名
	  $h->{type}		カラム型
	  $h->{index}		INDEX化するか
	  $h->{unique}		そのカラムにユニーク制約を付けるか
	  $h->{not_null}	NOT NULL制約を付けるか
	  $h->{default}		デフォルト値
	  $h->{ref}		外部キー制約（ table_name.col_name 形式の文字列 ）

	  $h->{index_tdb}	TextDBの時にはINDEX化する。(※)

　テーブル名、カラム名に使用出来るのは半角英数と "_" のみです。
　カラム名 pkey は主キー（シリアル型/auto_incrementのint型）として予約されています。
このカラムは指定しなくても無条件に生成されます。
　外部キー制約は、実装によって無効な場合があります。
　またデータベース側に型チェックを期待してはいけません。

Ret:
	$r  = 0			成功
	$r != 0			失敗

※TextDBでは、$_->{index} または $_->{index_tdb} が指定された要素がindexになります。
　テキストDBは検索対象となる要素は、index化しないとパフォーマンスが悪化します。
（全文検索の対象などの大きいデータは除く。
　index化するデータ量が極端に増えると逆にパスォーマンスが低下します。）

================================================================================
●[share3]テーブルの作成
================================================================================
$r = $self->create_table_wrapper($table, \%h);

　より簡易なインターフェイスでテーブルを作成するための wrapper。

（例）
	my %cols;
	$cols{text}    = [ qw(id name pass info) ];
	$cols{ltext}   = [ qw(largetext) ];
	$cols{int}     = [ qw(regist_tm update_tm login_count login_tm fail_count fail_tm) ];
	$cols{float}   = [ qw(float_number) ];
	$cols{flag}    = [ qw(disable isadmin) ];
	$cols{idx}     = [ qw(id regist_tm isadmin) ];
	$cols{idx_tdb} = [ qw(id regist_tm isadmin) ];
	$cols{unique}  = [ qw(id) ];
	$cols{notnull} = [ qw(id name) ];
	$cols{ref}     = { id   => "id_xxx_table.id" };
	$cols{default} = { info => "a@b.c" };
	my $r = $DB->create_table_wrapper($table, \%cols);

================================================================================
●テーブルの確認
================================================================================
$r = $self->find_table( $table );

	$table		テーブル名

Ret:
	$r  = 0		見つからない（存在しない）
	$r  = 1		見つかった（存在する）

================================================================================
●テーブルの作成
================================================================================
$r = $self->drop_table($table);

	$table		テーブル名

Ret:
	$r  = 0		成功
	$r != 0		失敗（1=テーブルが見つからない，2以上=それ以外）

　この関数はむやみに使用するべきではない。

================================================================================
●データの挿入
================================================================================
$r = $self->insert($table, \%h);

	$table		テーブル名
	$h{<col>}	カラム col のデータ
	$h{*<col>}	カラムデータを直接指定（例）$h{'*x'}=CURRENT_TIMESTAMP

　既に同じpkeyが存在した場合、挿入自体が失敗する。
　pkeyを省略した場合、自動で番号が振られる。

（Text-DBの制約）$h{*<col>} は使用できません。

Ret:
	$r = 0		失敗
	$r		成功：挿入したデータの pkey

================================================================================
●pkeyの生成
================================================================================
$r = $self->generate_pkey($table);

	$table		テーブル名

Ret:
	$r = 0		失敗
	$r>0		一意性が保証された pkey

================================================================================
●データの更新
================================================================================
$r = $self->update_match($table, \%h, $col, $val);
$r = $self->update_match($table, \%h, $col, $val, $col2, $val2, ...);

	$table		テーブル名

	$h{<col>}	カラム col のデータ
	$h{*<col>}	カラムデータを直接指定（例）$h{'*x'}=x+1, $h{'*x'}=CURRENT_TIMESTAMP

	$col		検索カラム名
	$val		一致検索する値。複数値の場合は配列refを与える

　条件をすべて省略すると、すべての行を更新します。
　条件は「カラム名と値」の組ごとに追加してください。
  カラム名の手前に'-'をつけると一致しない値を検索します。

（Text-DBの制約）
　$h{*<col>} で使用できるのは () と単純な加減乗除のみです。関数は呼び出せません。
　文字列操作は想定していません。正常に動作する式のみ動作します。
	（許可演算子）+ - * / % | & < >
　$h{<col>} select_group_by と $h{*<col>}の重複は禁止です。重複の場合の動作は不定です。

Ret:
	$r  = 0		失敗
	$r != 0		成功（更新した行数）

================================================================================
●データの削除
================================================================================
$r = $self->delete_match($table, $col, $val);
$r = $self->delete_match($table, $col, $val, $col2, $val2, ...);

	$table		テーブル名

	$col		検索カラム名
	$val		一致検索する値。複数値の場合は配列refを与える

　条件をすべて省略すると、すべての行を削除します
　条件は「カラム名と値」の組ごとに追加してください。
  カラム名の手前に'-'をつけると一致しない値を検索します。

Ret:
	$r = 0		失敗
	$r		成功（削除した行数）

================================================================================
●[share]データの簡易検索
================================================================================
$rah = $self->select_match($table, $col, $val);
$rah = $self->select_match($table, $col, $val, $col2, $val2, ...);

	$table		テーブル名

	$col		検索カラム名
	$val		一致検索する値。複数値の場合は配列refを与える

　条件は「カラム名と値」の組ごとに追加してください。

　$match の特殊指定。詳細は select を参照
	*limit			limitを指定
	*sort			sortを指定。カラム名に'-'を付けると降順
	*no_error		no_errorを指定
	*cols			取得するカラムを指定
	-(col)			マッチしない指定

（例）sort複数指定
	select_match('table', '*sort', 'col1', '*sort', 'col2');

Ret:
	$rah			（検索結果の）ハッシュリファレンスの配列


================================================================================
●[share]データの簡易検索（１つ抽出）
================================================================================
$h = $self->select_match_limit1($table, $col, $val);
$h = $self->select_match_limit1($table, $col, $val, $col2, $val2, ...);

	$table		テーブル名

　マッチング引数は select_match を参照。
　内部的に select_match() を呼び出しています。

Ret:
	$h		（成功時）ハッシュリファレンス
	$h=undef	（失敗時）

================================================================================
●[share]データの簡易検索（存在確認）
================================================================================
$pkey = $self->select_match_pkey1($table, $col, $val);
$pkey = $self->select_match_pkey1($table, $col, $val, $col2, $val2, ...);

	$table		テーブル名

　指定した条件に合う行の、「pkey」を1つだけ取り出します。
　内部的に select_match() を呼び出しています。

Ret:
	0 以外		（成功時）
	0		（失敗時）

================================================================================
●データの検索
================================================================================
 $rah         = $self->select($table, \%h);
($rah, $hits) = $self->select($table, \%h);

	$table			テーブル名

	$h{match}->{<col>}	一致検索。col とその値。
				値が配列リファレンスのとき、いずれかの値との一致検索
	$h{not_match}->{<col>}	不一致検索。配列指定可能。

	$h{max}->{<col>}	値比較（以下）
	$h{min}->{<col>}	値比較（以上）
	$h{lt}->{<col>}		値比較（指定した値より小さい）
	$h{gt}->{<col>}		値比較（指定した値より大きい）
	$h{flag}->{<col>}	フラグ検索 col と論理（1 / 0）

	$h{is_null}		IS NULL検索をするカラム（配列リファレンス）
	$h{not_null}		IS NOT NULL検索をするカラム（配列リファレンス）
				※DBにおいて "" は常に NULL として扱われる

	$h{search_words}	検索文字列（配列リファレンス） / 大文字小文字区別なし
	$h{search_not}		含まない検索をする文字列（配列リファレンス）
	$h{search_cols}		検索対象カラム（配列リファレンス）
	$h{search_match}	一致検索カラム（大文字小文字区別なし / 配列リファレンス）
	$h{search_equal}	一致検索カラム（大文字小文字区別あり / 配列リファレンス）

	$h{offset}		取得開始するオフセット
	$h{limit}		取得最大行数

	$h{sort}		ソートするカラム。複数指定が配列refで。
				"-col" と指定すると、降順になる。
	$h{sort_rev}		逆順ソート指定。"0"か"1"を指定。0:昇順 1:降順。
				$h{sort}が配列refのとき、これも配列refにする。

	$h{cols}->[]		必要なカラムを指定（配列リファレンスかスカラ）
				cols が未定義時はすべて

	$h{no_error}		失敗しても error ではなく warning に出力する

	$h{want_sth}		(RDBMSのみ) 取得結果ではなく $sth を返す。

　複数検索条件の場合 and として扱われる。

　特殊な引数
	$h{RDB_where}		(RDBMSのみ) where条件を直接「追加(and)」指定する。
				危険であるので変数埋め込みは絶対しないこと。
				「' ; \」および「\x80-\xff」以降は除去される。
	$h{RDB_values}		(RDBMSのみ) RDB_whereの「?」に与える値
	$h{RDB_order}		(RDBMSのみ) ORDER条件を直接指定する。
				sort条件と並列指定した場合は、
				RDB_order の後にsort条件が評価される。

Ret:
	$rah			（検索結果の）ハッシュリファレンスの配列
	$hits			該当件数

================================================================================
●データの集計
================================================================================
$rah = $self->select_by_group($table, \%h);

	$table			テーブル名
	$h{group_by}		GROUP BY をするカラム（1つのみ。省略可）
	$h{max_cols}		最大値をとるカラム（配列可/省略可）
	$h{min_cols}		最小値をとるカラム（配列可/省略可）
	$h{sum_cols}		総和をとるカラム　（配列可/省略可）

	$h{xxx}			ソート条件/検索条件。
				select と同一のものが使用できる。

Ret:
	$rah			（検索結果の）ハッシュリファレンスの配列
				_count  : count(pkey)
				xxx_sum : sum('xxx')

　SQL で書けば次のようになる。
SELECT	count(pkey) AS _count,
	max($max_col) AS "${max_col}_max",
	sum($sum_col) AS "${sum_col}_sum",
	$group_col FROM $table GROUP BY $group_col

================================================================================
●トランザクション
================================================================================
$self->begin();
$self->commit();
$self->rollback();

　トランザクションを操作しますが、DBライブラリによっては実装されてないかも
しれません。この関数はもっぱら大量の更新処理を高速に処理するため（中間の書
き戻しを省略するため）に使用されます。

　コミット失敗時は自動的にrollbackされます。rollbackの呼び出しは不要です。

・Text-DB
select/insert/update/delete のみ対応。
同じテーブルに対し同時に１つしかトランザクションは走らない。

・PostgreSQL
正しくトランザクションが処理されます。

・MySQL(MyISAM)
一切のトランザクション動作が期待できません。

Ret:
	$r = $self->commit(); 
		 0	成功
		-1	ロールバック（途中でエラーがあった）

================================================================================
●[share3]オプショナル関数の取得
================================================================================
$h = $self->get_options();
Ret:
	$h{"function name"}	実装されているオプショナル関数をキー値として返す


################################################################################
■テーブルカラムの変更
################################################################################
================================================================================
●カラム追加
================================================================================
$r = $self->add_column($table, \%h);

	%h		追加するカラム情報（create_table参照）

Ret:
	$r  = 0		成功
	$r != 0		失敗

================================================================================
●カラム削除
================================================================================
$r = $self->drop_column($table, $colum_name);

	$colum_name	削除するカラム名

　削除したカラムのデータが、select したときに返ることもある。
（そういう実装も許される）

Ret:
	$r  = 0		成功
	$r != 0		失敗

================================================================================
●テーブルindexの追加
================================================================================
$r = $self->add_index($table, $colum_name);

	$colum_name	indexを追加するカラム名

Ret:
	$r  = 0		成功
	$r != 0		失敗

################################################################################
■（特殊）DBD関数
################################################################################

　DBI/DBDでのみ実装されている関数群。

================================================================================
●[share] where句を指定して簡易select
================================================================================
$ary  = $self->select_where($table, $where);
$ary  = $self->select_where($table, $where, @ary);
$h    = $self->select_where_limit1($table, $where);
$h    = $self->select_where_limit1($table, $where, @ary);
$pkey = $self->select_where_pkey1 ($table, $where);
$pkey = $self->select_where_pkey1 ($table, $where, @ary);

	where句を指定して、簡易検索を実行します。
	内部的には、RDB_whereを指定し select() を呼び出しています。

（例）
	$self->select_where($table, 'x is null');
	$self->select_where_limit1($table, 'x=3 OR y!=4');
	$self->select_where_pkey1 ($table, 'x_pkey=? OR y_pkey=?', 3, 4);

================================================================================
●where句のみの生成
================================================================================
($where_sql, $values_ary) = $self->generate_select_where($h)

	$h	select()の引数と同一。

	DBの仕様に沿った「where句」を生成します。

Ret:
	$where_sql	空文字 または ' WHERE pkey is null' 等の文字列
	$values_ary	WHEREのフレーズホルダー用の配列リファレンス

================================================================================
●dbhのロード
================================================================================
$dbh = $self->load_dbh();

	DBIのコネクションハンドル $dbh をロードします。
	特定のDBMを使用する場合以外は使用しないでください。

================================================================================
●prepare
================================================================================
$sth = $self->prepare();

	DBIに対し prepare を発行し戻り値を得ます。
	特定のDBMを使用する場合以外は使用しないでください。

================================================================================
●切断/再接続
================================================================================
$self->disconnect();
$self->reconnect( $flag );

	$flag …… 1 の場合、強制再接続します。

	DB と接続が切れている場合、再接続します。
	接続が切れていなければ何もしません。
	DBI環境以外でも実装されますが、何も処理しません。

================================================================================
●do_sql
================================================================================
$sth = $self->do_sql("SQL")
$sth = $self->do_sql("SELECT * FROM table WHERE pkey=? AND x=? OR y=?", @ary)

Ret:
	$sth	execute済の DBI $sth が返されます。

================================================================================
●do_sql_rows
================================================================================
$rows = $self->do_sql_rows("SQL")

Ret:
	$rows	DBI の $sth->rows が返されます。
		失敗した場合は undef が返されます。

================================================================================
●select_sql
================================================================================
$hary = $self->select_sql("SELECT * FROM table WHERE pkey=? AND x=? OR y=?", @ary)

Ret:
	$hary	結果のハッシュ配列が返されます。
		該当がない場合やエラー時は空配列が返ります。

################################################################################
■エラー関連
################################################################################
================================================================================
●set_debug
================================================================================
my $r = $self->set_debug( $flag );
	$flag = 0	debug off（ディフォルト）
	$flag = 1	debug on（実行SQL文をdebug出力 / DB_textでは意味なし）

Ret:
	$r		設定前のモード

================================================================================
●set_noerror
================================================================================
my $r = $self->set_noerror( $flag );
	$flag = 0	エラーは error() に投げる
	$flag = 1	エラーは warning() に投げる

Ret:
	$r		設定前のモード

